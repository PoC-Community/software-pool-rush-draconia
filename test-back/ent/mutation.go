// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"draconia/ent/character"
	"draconia/ent/predicate"
	"draconia/ent/user"
	"errors"
	"fmt"
	"sync"

	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharacter = "Character"
	TypeUser      = "User"
)

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	name                       *string
	combat                     *int
	addcombat                  *int
	connaissance               *int
	addconnaissance            *int
	discretion                 *int
	adddiscretion              *int
	endurance                  *int
	addendurance               *int
	force                      *int
	addforce                   *int
	habilite                   *int
	addhabilite                *int
	mouvement                  *int
	addmouvement               *int
	perception                 *int
	addperception              *int
	sociabilite                *int
	addsociabilite             *int
	survie                     *int
	addsurvie                  *int
	tir                        *int
	addtir                     *int
	volonte                    *int
	addvolonte                 *int
	exp                        *int
	addexp                     *int
	armes_hast                 *int
	addarmes_hast              *int
	armes_moine                *int
	addarmes_moine             *int
	armes_doubles              *int
	addarmes_doubles           *int
	armes_naturelles           *int
	addarmes_naturelles        *int
	batons                     *int
	addbatons                  *int
	cimeterres                 *int
	addcimeterres              *int
	fleaux                     *int
	addfleaux                  *int
	fouets                     *int
	addfouets                  *int
	haches                     *int
	addhaches                  *int
	katanas                    *int
	addkatanas                 *int
	lames_legeres              *int
	addlames_legeres           *int
	lames_lourdes              *int
	addlames_lourdes           *int
	lances                     *int
	addlances                  *int
	marteaux                   *int
	addmarteaux                *int
	mains_nues                 *int
	addmains_nues              *int
	mysteres                   *int
	addmysteres                *int
	exploration_souterraine    *int
	addexploration_souterraine *int
	ingenierie                 *int
	addingenierie              *int
	geographie                 *int
	addgeographie              *int
	histoire                   *int
	addhistoire                *int
	folklore                   *int
	addfolklore                *int
	nature                     *int
	addnature                  *int
	noblesse                   *int
	addnoblesse                *int
	plans                      *int
	addplans                   *int
	religon                    *int
	addreligon                 *int
	anatomie                   *int
	addanatomie                *int
	magie_theorique            *int
	addmagie_theorique         *int
	economie                   *int
	addeconomie                *int
	linguistique               *int
	addlinguistique            *int
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Character, error)
	predicates                 []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id uuid.UUID) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Character entities.
func (m *CharacterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CharacterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharacterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharacterMutation) ResetName() {
	m.name = nil
}

// SetCombat sets the "combat" field.
func (m *CharacterMutation) SetCombat(i int) {
	m.combat = &i
	m.addcombat = nil
}

// Combat returns the value of the "combat" field in the mutation.
func (m *CharacterMutation) Combat() (r int, exists bool) {
	v := m.combat
	if v == nil {
		return
	}
	return *v, true
}

// OldCombat returns the old "combat" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCombat(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombat: %w", err)
	}
	return oldValue.Combat, nil
}

// AddCombat adds i to the "combat" field.
func (m *CharacterMutation) AddCombat(i int) {
	if m.addcombat != nil {
		*m.addcombat += i
	} else {
		m.addcombat = &i
	}
}

// AddedCombat returns the value that was added to the "combat" field in this mutation.
func (m *CharacterMutation) AddedCombat() (r int, exists bool) {
	v := m.addcombat
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombat resets all changes to the "combat" field.
func (m *CharacterMutation) ResetCombat() {
	m.combat = nil
	m.addcombat = nil
}

// SetConnaissance sets the "connaissance" field.
func (m *CharacterMutation) SetConnaissance(i int) {
	m.connaissance = &i
	m.addconnaissance = nil
}

// Connaissance returns the value of the "connaissance" field in the mutation.
func (m *CharacterMutation) Connaissance() (r int, exists bool) {
	v := m.connaissance
	if v == nil {
		return
	}
	return *v, true
}

// OldConnaissance returns the old "connaissance" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldConnaissance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnaissance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnaissance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnaissance: %w", err)
	}
	return oldValue.Connaissance, nil
}

// AddConnaissance adds i to the "connaissance" field.
func (m *CharacterMutation) AddConnaissance(i int) {
	if m.addconnaissance != nil {
		*m.addconnaissance += i
	} else {
		m.addconnaissance = &i
	}
}

// AddedConnaissance returns the value that was added to the "connaissance" field in this mutation.
func (m *CharacterMutation) AddedConnaissance() (r int, exists bool) {
	v := m.addconnaissance
	if v == nil {
		return
	}
	return *v, true
}

// ResetConnaissance resets all changes to the "connaissance" field.
func (m *CharacterMutation) ResetConnaissance() {
	m.connaissance = nil
	m.addconnaissance = nil
}

// SetDiscretion sets the "discretion" field.
func (m *CharacterMutation) SetDiscretion(i int) {
	m.discretion = &i
	m.adddiscretion = nil
}

// Discretion returns the value of the "discretion" field in the mutation.
func (m *CharacterMutation) Discretion() (r int, exists bool) {
	v := m.discretion
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscretion returns the old "discretion" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldDiscretion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscretion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscretion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscretion: %w", err)
	}
	return oldValue.Discretion, nil
}

// AddDiscretion adds i to the "discretion" field.
func (m *CharacterMutation) AddDiscretion(i int) {
	if m.adddiscretion != nil {
		*m.adddiscretion += i
	} else {
		m.adddiscretion = &i
	}
}

// AddedDiscretion returns the value that was added to the "discretion" field in this mutation.
func (m *CharacterMutation) AddedDiscretion() (r int, exists bool) {
	v := m.adddiscretion
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscretion resets all changes to the "discretion" field.
func (m *CharacterMutation) ResetDiscretion() {
	m.discretion = nil
	m.adddiscretion = nil
}

// SetEndurance sets the "endurance" field.
func (m *CharacterMutation) SetEndurance(i int) {
	m.endurance = &i
	m.addendurance = nil
}

// Endurance returns the value of the "endurance" field in the mutation.
func (m *CharacterMutation) Endurance() (r int, exists bool) {
	v := m.endurance
	if v == nil {
		return
	}
	return *v, true
}

// OldEndurance returns the old "endurance" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldEndurance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndurance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndurance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndurance: %w", err)
	}
	return oldValue.Endurance, nil
}

// AddEndurance adds i to the "endurance" field.
func (m *CharacterMutation) AddEndurance(i int) {
	if m.addendurance != nil {
		*m.addendurance += i
	} else {
		m.addendurance = &i
	}
}

// AddedEndurance returns the value that was added to the "endurance" field in this mutation.
func (m *CharacterMutation) AddedEndurance() (r int, exists bool) {
	v := m.addendurance
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndurance resets all changes to the "endurance" field.
func (m *CharacterMutation) ResetEndurance() {
	m.endurance = nil
	m.addendurance = nil
}

// SetForce sets the "force" field.
func (m *CharacterMutation) SetForce(i int) {
	m.force = &i
	m.addforce = nil
}

// Force returns the value of the "force" field in the mutation.
func (m *CharacterMutation) Force() (r int, exists bool) {
	v := m.force
	if v == nil {
		return
	}
	return *v, true
}

// OldForce returns the old "force" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldForce(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForce: %w", err)
	}
	return oldValue.Force, nil
}

// AddForce adds i to the "force" field.
func (m *CharacterMutation) AddForce(i int) {
	if m.addforce != nil {
		*m.addforce += i
	} else {
		m.addforce = &i
	}
}

// AddedForce returns the value that was added to the "force" field in this mutation.
func (m *CharacterMutation) AddedForce() (r int, exists bool) {
	v := m.addforce
	if v == nil {
		return
	}
	return *v, true
}

// ResetForce resets all changes to the "force" field.
func (m *CharacterMutation) ResetForce() {
	m.force = nil
	m.addforce = nil
}

// SetHabilite sets the "habilite" field.
func (m *CharacterMutation) SetHabilite(i int) {
	m.habilite = &i
	m.addhabilite = nil
}

// Habilite returns the value of the "habilite" field in the mutation.
func (m *CharacterMutation) Habilite() (r int, exists bool) {
	v := m.habilite
	if v == nil {
		return
	}
	return *v, true
}

// OldHabilite returns the old "habilite" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldHabilite(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHabilite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHabilite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHabilite: %w", err)
	}
	return oldValue.Habilite, nil
}

// AddHabilite adds i to the "habilite" field.
func (m *CharacterMutation) AddHabilite(i int) {
	if m.addhabilite != nil {
		*m.addhabilite += i
	} else {
		m.addhabilite = &i
	}
}

// AddedHabilite returns the value that was added to the "habilite" field in this mutation.
func (m *CharacterMutation) AddedHabilite() (r int, exists bool) {
	v := m.addhabilite
	if v == nil {
		return
	}
	return *v, true
}

// ResetHabilite resets all changes to the "habilite" field.
func (m *CharacterMutation) ResetHabilite() {
	m.habilite = nil
	m.addhabilite = nil
}

// SetMouvement sets the "mouvement" field.
func (m *CharacterMutation) SetMouvement(i int) {
	m.mouvement = &i
	m.addmouvement = nil
}

// Mouvement returns the value of the "mouvement" field in the mutation.
func (m *CharacterMutation) Mouvement() (r int, exists bool) {
	v := m.mouvement
	if v == nil {
		return
	}
	return *v, true
}

// OldMouvement returns the old "mouvement" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldMouvement(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMouvement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMouvement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMouvement: %w", err)
	}
	return oldValue.Mouvement, nil
}

// AddMouvement adds i to the "mouvement" field.
func (m *CharacterMutation) AddMouvement(i int) {
	if m.addmouvement != nil {
		*m.addmouvement += i
	} else {
		m.addmouvement = &i
	}
}

// AddedMouvement returns the value that was added to the "mouvement" field in this mutation.
func (m *CharacterMutation) AddedMouvement() (r int, exists bool) {
	v := m.addmouvement
	if v == nil {
		return
	}
	return *v, true
}

// ResetMouvement resets all changes to the "mouvement" field.
func (m *CharacterMutation) ResetMouvement() {
	m.mouvement = nil
	m.addmouvement = nil
}

// SetPerception sets the "perception" field.
func (m *CharacterMutation) SetPerception(i int) {
	m.perception = &i
	m.addperception = nil
}

// Perception returns the value of the "perception" field in the mutation.
func (m *CharacterMutation) Perception() (r int, exists bool) {
	v := m.perception
	if v == nil {
		return
	}
	return *v, true
}

// OldPerception returns the old "perception" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldPerception(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerception is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerception requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerception: %w", err)
	}
	return oldValue.Perception, nil
}

// AddPerception adds i to the "perception" field.
func (m *CharacterMutation) AddPerception(i int) {
	if m.addperception != nil {
		*m.addperception += i
	} else {
		m.addperception = &i
	}
}

// AddedPerception returns the value that was added to the "perception" field in this mutation.
func (m *CharacterMutation) AddedPerception() (r int, exists bool) {
	v := m.addperception
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerception resets all changes to the "perception" field.
func (m *CharacterMutation) ResetPerception() {
	m.perception = nil
	m.addperception = nil
}

// SetSociabilite sets the "sociabilite" field.
func (m *CharacterMutation) SetSociabilite(i int) {
	m.sociabilite = &i
	m.addsociabilite = nil
}

// Sociabilite returns the value of the "sociabilite" field in the mutation.
func (m *CharacterMutation) Sociabilite() (r int, exists bool) {
	v := m.sociabilite
	if v == nil {
		return
	}
	return *v, true
}

// OldSociabilite returns the old "sociabilite" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSociabilite(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSociabilite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSociabilite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSociabilite: %w", err)
	}
	return oldValue.Sociabilite, nil
}

// AddSociabilite adds i to the "sociabilite" field.
func (m *CharacterMutation) AddSociabilite(i int) {
	if m.addsociabilite != nil {
		*m.addsociabilite += i
	} else {
		m.addsociabilite = &i
	}
}

// AddedSociabilite returns the value that was added to the "sociabilite" field in this mutation.
func (m *CharacterMutation) AddedSociabilite() (r int, exists bool) {
	v := m.addsociabilite
	if v == nil {
		return
	}
	return *v, true
}

// ResetSociabilite resets all changes to the "sociabilite" field.
func (m *CharacterMutation) ResetSociabilite() {
	m.sociabilite = nil
	m.addsociabilite = nil
}

// SetSurvie sets the "survie" field.
func (m *CharacterMutation) SetSurvie(i int) {
	m.survie = &i
	m.addsurvie = nil
}

// Survie returns the value of the "survie" field in the mutation.
func (m *CharacterMutation) Survie() (r int, exists bool) {
	v := m.survie
	if v == nil {
		return
	}
	return *v, true
}

// OldSurvie returns the old "survie" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSurvie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurvie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurvie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurvie: %w", err)
	}
	return oldValue.Survie, nil
}

// AddSurvie adds i to the "survie" field.
func (m *CharacterMutation) AddSurvie(i int) {
	if m.addsurvie != nil {
		*m.addsurvie += i
	} else {
		m.addsurvie = &i
	}
}

// AddedSurvie returns the value that was added to the "survie" field in this mutation.
func (m *CharacterMutation) AddedSurvie() (r int, exists bool) {
	v := m.addsurvie
	if v == nil {
		return
	}
	return *v, true
}

// ResetSurvie resets all changes to the "survie" field.
func (m *CharacterMutation) ResetSurvie() {
	m.survie = nil
	m.addsurvie = nil
}

// SetTir sets the "tir" field.
func (m *CharacterMutation) SetTir(i int) {
	m.tir = &i
	m.addtir = nil
}

// Tir returns the value of the "tir" field in the mutation.
func (m *CharacterMutation) Tir() (r int, exists bool) {
	v := m.tir
	if v == nil {
		return
	}
	return *v, true
}

// OldTir returns the old "tir" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTir(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTir: %w", err)
	}
	return oldValue.Tir, nil
}

// AddTir adds i to the "tir" field.
func (m *CharacterMutation) AddTir(i int) {
	if m.addtir != nil {
		*m.addtir += i
	} else {
		m.addtir = &i
	}
}

// AddedTir returns the value that was added to the "tir" field in this mutation.
func (m *CharacterMutation) AddedTir() (r int, exists bool) {
	v := m.addtir
	if v == nil {
		return
	}
	return *v, true
}

// ResetTir resets all changes to the "tir" field.
func (m *CharacterMutation) ResetTir() {
	m.tir = nil
	m.addtir = nil
}

// SetVolonte sets the "volonte" field.
func (m *CharacterMutation) SetVolonte(i int) {
	m.volonte = &i
	m.addvolonte = nil
}

// Volonte returns the value of the "volonte" field in the mutation.
func (m *CharacterMutation) Volonte() (r int, exists bool) {
	v := m.volonte
	if v == nil {
		return
	}
	return *v, true
}

// OldVolonte returns the old "volonte" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldVolonte(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolonte is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolonte requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolonte: %w", err)
	}
	return oldValue.Volonte, nil
}

// AddVolonte adds i to the "volonte" field.
func (m *CharacterMutation) AddVolonte(i int) {
	if m.addvolonte != nil {
		*m.addvolonte += i
	} else {
		m.addvolonte = &i
	}
}

// AddedVolonte returns the value that was added to the "volonte" field in this mutation.
func (m *CharacterMutation) AddedVolonte() (r int, exists bool) {
	v := m.addvolonte
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolonte resets all changes to the "volonte" field.
func (m *CharacterMutation) ResetVolonte() {
	m.volonte = nil
	m.addvolonte = nil
}

// SetExp sets the "exp" field.
func (m *CharacterMutation) SetExp(i int) {
	m.exp = &i
	m.addexp = nil
}

// Exp returns the value of the "exp" field in the mutation.
func (m *CharacterMutation) Exp() (r int, exists bool) {
	v := m.exp
	if v == nil {
		return
	}
	return *v, true
}

// OldExp returns the old "exp" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldExp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExp: %w", err)
	}
	return oldValue.Exp, nil
}

// AddExp adds i to the "exp" field.
func (m *CharacterMutation) AddExp(i int) {
	if m.addexp != nil {
		*m.addexp += i
	} else {
		m.addexp = &i
	}
}

// AddedExp returns the value that was added to the "exp" field in this mutation.
func (m *CharacterMutation) AddedExp() (r int, exists bool) {
	v := m.addexp
	if v == nil {
		return
	}
	return *v, true
}

// ResetExp resets all changes to the "exp" field.
func (m *CharacterMutation) ResetExp() {
	m.exp = nil
	m.addexp = nil
}

// SetArmesHast sets the "armes_hast" field.
func (m *CharacterMutation) SetArmesHast(i int) {
	m.armes_hast = &i
	m.addarmes_hast = nil
}

// ArmesHast returns the value of the "armes_hast" field in the mutation.
func (m *CharacterMutation) ArmesHast() (r int, exists bool) {
	v := m.armes_hast
	if v == nil {
		return
	}
	return *v, true
}

// OldArmesHast returns the old "armes_hast" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldArmesHast(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArmesHast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArmesHast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArmesHast: %w", err)
	}
	return oldValue.ArmesHast, nil
}

// AddArmesHast adds i to the "armes_hast" field.
func (m *CharacterMutation) AddArmesHast(i int) {
	if m.addarmes_hast != nil {
		*m.addarmes_hast += i
	} else {
		m.addarmes_hast = &i
	}
}

// AddedArmesHast returns the value that was added to the "armes_hast" field in this mutation.
func (m *CharacterMutation) AddedArmesHast() (r int, exists bool) {
	v := m.addarmes_hast
	if v == nil {
		return
	}
	return *v, true
}

// ResetArmesHast resets all changes to the "armes_hast" field.
func (m *CharacterMutation) ResetArmesHast() {
	m.armes_hast = nil
	m.addarmes_hast = nil
}

// SetArmesMoine sets the "armes_moine" field.
func (m *CharacterMutation) SetArmesMoine(i int) {
	m.armes_moine = &i
	m.addarmes_moine = nil
}

// ArmesMoine returns the value of the "armes_moine" field in the mutation.
func (m *CharacterMutation) ArmesMoine() (r int, exists bool) {
	v := m.armes_moine
	if v == nil {
		return
	}
	return *v, true
}

// OldArmesMoine returns the old "armes_moine" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldArmesMoine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArmesMoine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArmesMoine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArmesMoine: %w", err)
	}
	return oldValue.ArmesMoine, nil
}

// AddArmesMoine adds i to the "armes_moine" field.
func (m *CharacterMutation) AddArmesMoine(i int) {
	if m.addarmes_moine != nil {
		*m.addarmes_moine += i
	} else {
		m.addarmes_moine = &i
	}
}

// AddedArmesMoine returns the value that was added to the "armes_moine" field in this mutation.
func (m *CharacterMutation) AddedArmesMoine() (r int, exists bool) {
	v := m.addarmes_moine
	if v == nil {
		return
	}
	return *v, true
}

// ResetArmesMoine resets all changes to the "armes_moine" field.
func (m *CharacterMutation) ResetArmesMoine() {
	m.armes_moine = nil
	m.addarmes_moine = nil
}

// SetArmesDoubles sets the "armes_doubles" field.
func (m *CharacterMutation) SetArmesDoubles(i int) {
	m.armes_doubles = &i
	m.addarmes_doubles = nil
}

// ArmesDoubles returns the value of the "armes_doubles" field in the mutation.
func (m *CharacterMutation) ArmesDoubles() (r int, exists bool) {
	v := m.armes_doubles
	if v == nil {
		return
	}
	return *v, true
}

// OldArmesDoubles returns the old "armes_doubles" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldArmesDoubles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArmesDoubles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArmesDoubles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArmesDoubles: %w", err)
	}
	return oldValue.ArmesDoubles, nil
}

// AddArmesDoubles adds i to the "armes_doubles" field.
func (m *CharacterMutation) AddArmesDoubles(i int) {
	if m.addarmes_doubles != nil {
		*m.addarmes_doubles += i
	} else {
		m.addarmes_doubles = &i
	}
}

// AddedArmesDoubles returns the value that was added to the "armes_doubles" field in this mutation.
func (m *CharacterMutation) AddedArmesDoubles() (r int, exists bool) {
	v := m.addarmes_doubles
	if v == nil {
		return
	}
	return *v, true
}

// ResetArmesDoubles resets all changes to the "armes_doubles" field.
func (m *CharacterMutation) ResetArmesDoubles() {
	m.armes_doubles = nil
	m.addarmes_doubles = nil
}

// SetArmesNaturelles sets the "armes_naturelles" field.
func (m *CharacterMutation) SetArmesNaturelles(i int) {
	m.armes_naturelles = &i
	m.addarmes_naturelles = nil
}

// ArmesNaturelles returns the value of the "armes_naturelles" field in the mutation.
func (m *CharacterMutation) ArmesNaturelles() (r int, exists bool) {
	v := m.armes_naturelles
	if v == nil {
		return
	}
	return *v, true
}

// OldArmesNaturelles returns the old "armes_naturelles" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldArmesNaturelles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArmesNaturelles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArmesNaturelles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArmesNaturelles: %w", err)
	}
	return oldValue.ArmesNaturelles, nil
}

// AddArmesNaturelles adds i to the "armes_naturelles" field.
func (m *CharacterMutation) AddArmesNaturelles(i int) {
	if m.addarmes_naturelles != nil {
		*m.addarmes_naturelles += i
	} else {
		m.addarmes_naturelles = &i
	}
}

// AddedArmesNaturelles returns the value that was added to the "armes_naturelles" field in this mutation.
func (m *CharacterMutation) AddedArmesNaturelles() (r int, exists bool) {
	v := m.addarmes_naturelles
	if v == nil {
		return
	}
	return *v, true
}

// ResetArmesNaturelles resets all changes to the "armes_naturelles" field.
func (m *CharacterMutation) ResetArmesNaturelles() {
	m.armes_naturelles = nil
	m.addarmes_naturelles = nil
}

// SetBatons sets the "batons" field.
func (m *CharacterMutation) SetBatons(i int) {
	m.batons = &i
	m.addbatons = nil
}

// Batons returns the value of the "batons" field in the mutation.
func (m *CharacterMutation) Batons() (r int, exists bool) {
	v := m.batons
	if v == nil {
		return
	}
	return *v, true
}

// OldBatons returns the old "batons" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldBatons(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatons: %w", err)
	}
	return oldValue.Batons, nil
}

// AddBatons adds i to the "batons" field.
func (m *CharacterMutation) AddBatons(i int) {
	if m.addbatons != nil {
		*m.addbatons += i
	} else {
		m.addbatons = &i
	}
}

// AddedBatons returns the value that was added to the "batons" field in this mutation.
func (m *CharacterMutation) AddedBatons() (r int, exists bool) {
	v := m.addbatons
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatons resets all changes to the "batons" field.
func (m *CharacterMutation) ResetBatons() {
	m.batons = nil
	m.addbatons = nil
}

// SetCimeterres sets the "cimeterres" field.
func (m *CharacterMutation) SetCimeterres(i int) {
	m.cimeterres = &i
	m.addcimeterres = nil
}

// Cimeterres returns the value of the "cimeterres" field in the mutation.
func (m *CharacterMutation) Cimeterres() (r int, exists bool) {
	v := m.cimeterres
	if v == nil {
		return
	}
	return *v, true
}

// OldCimeterres returns the old "cimeterres" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCimeterres(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCimeterres is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCimeterres requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCimeterres: %w", err)
	}
	return oldValue.Cimeterres, nil
}

// AddCimeterres adds i to the "cimeterres" field.
func (m *CharacterMutation) AddCimeterres(i int) {
	if m.addcimeterres != nil {
		*m.addcimeterres += i
	} else {
		m.addcimeterres = &i
	}
}

// AddedCimeterres returns the value that was added to the "cimeterres" field in this mutation.
func (m *CharacterMutation) AddedCimeterres() (r int, exists bool) {
	v := m.addcimeterres
	if v == nil {
		return
	}
	return *v, true
}

// ResetCimeterres resets all changes to the "cimeterres" field.
func (m *CharacterMutation) ResetCimeterres() {
	m.cimeterres = nil
	m.addcimeterres = nil
}

// SetFleaux sets the "fleaux" field.
func (m *CharacterMutation) SetFleaux(i int) {
	m.fleaux = &i
	m.addfleaux = nil
}

// Fleaux returns the value of the "fleaux" field in the mutation.
func (m *CharacterMutation) Fleaux() (r int, exists bool) {
	v := m.fleaux
	if v == nil {
		return
	}
	return *v, true
}

// OldFleaux returns the old "fleaux" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldFleaux(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleaux is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleaux requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleaux: %w", err)
	}
	return oldValue.Fleaux, nil
}

// AddFleaux adds i to the "fleaux" field.
func (m *CharacterMutation) AddFleaux(i int) {
	if m.addfleaux != nil {
		*m.addfleaux += i
	} else {
		m.addfleaux = &i
	}
}

// AddedFleaux returns the value that was added to the "fleaux" field in this mutation.
func (m *CharacterMutation) AddedFleaux() (r int, exists bool) {
	v := m.addfleaux
	if v == nil {
		return
	}
	return *v, true
}

// ResetFleaux resets all changes to the "fleaux" field.
func (m *CharacterMutation) ResetFleaux() {
	m.fleaux = nil
	m.addfleaux = nil
}

// SetFouets sets the "fouets" field.
func (m *CharacterMutation) SetFouets(i int) {
	m.fouets = &i
	m.addfouets = nil
}

// Fouets returns the value of the "fouets" field in the mutation.
func (m *CharacterMutation) Fouets() (r int, exists bool) {
	v := m.fouets
	if v == nil {
		return
	}
	return *v, true
}

// OldFouets returns the old "fouets" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldFouets(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFouets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFouets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFouets: %w", err)
	}
	return oldValue.Fouets, nil
}

// AddFouets adds i to the "fouets" field.
func (m *CharacterMutation) AddFouets(i int) {
	if m.addfouets != nil {
		*m.addfouets += i
	} else {
		m.addfouets = &i
	}
}

// AddedFouets returns the value that was added to the "fouets" field in this mutation.
func (m *CharacterMutation) AddedFouets() (r int, exists bool) {
	v := m.addfouets
	if v == nil {
		return
	}
	return *v, true
}

// ResetFouets resets all changes to the "fouets" field.
func (m *CharacterMutation) ResetFouets() {
	m.fouets = nil
	m.addfouets = nil
}

// SetHaches sets the "haches" field.
func (m *CharacterMutation) SetHaches(i int) {
	m.haches = &i
	m.addhaches = nil
}

// Haches returns the value of the "haches" field in the mutation.
func (m *CharacterMutation) Haches() (r int, exists bool) {
	v := m.haches
	if v == nil {
		return
	}
	return *v, true
}

// OldHaches returns the old "haches" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldHaches(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHaches is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHaches requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHaches: %w", err)
	}
	return oldValue.Haches, nil
}

// AddHaches adds i to the "haches" field.
func (m *CharacterMutation) AddHaches(i int) {
	if m.addhaches != nil {
		*m.addhaches += i
	} else {
		m.addhaches = &i
	}
}

// AddedHaches returns the value that was added to the "haches" field in this mutation.
func (m *CharacterMutation) AddedHaches() (r int, exists bool) {
	v := m.addhaches
	if v == nil {
		return
	}
	return *v, true
}

// ResetHaches resets all changes to the "haches" field.
func (m *CharacterMutation) ResetHaches() {
	m.haches = nil
	m.addhaches = nil
}

// SetKatanas sets the "katanas" field.
func (m *CharacterMutation) SetKatanas(i int) {
	m.katanas = &i
	m.addkatanas = nil
}

// Katanas returns the value of the "katanas" field in the mutation.
func (m *CharacterMutation) Katanas() (r int, exists bool) {
	v := m.katanas
	if v == nil {
		return
	}
	return *v, true
}

// OldKatanas returns the old "katanas" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldKatanas(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKatanas is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKatanas requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKatanas: %w", err)
	}
	return oldValue.Katanas, nil
}

// AddKatanas adds i to the "katanas" field.
func (m *CharacterMutation) AddKatanas(i int) {
	if m.addkatanas != nil {
		*m.addkatanas += i
	} else {
		m.addkatanas = &i
	}
}

// AddedKatanas returns the value that was added to the "katanas" field in this mutation.
func (m *CharacterMutation) AddedKatanas() (r int, exists bool) {
	v := m.addkatanas
	if v == nil {
		return
	}
	return *v, true
}

// ResetKatanas resets all changes to the "katanas" field.
func (m *CharacterMutation) ResetKatanas() {
	m.katanas = nil
	m.addkatanas = nil
}

// SetLamesLegeres sets the "lames_legeres" field.
func (m *CharacterMutation) SetLamesLegeres(i int) {
	m.lames_legeres = &i
	m.addlames_legeres = nil
}

// LamesLegeres returns the value of the "lames_legeres" field in the mutation.
func (m *CharacterMutation) LamesLegeres() (r int, exists bool) {
	v := m.lames_legeres
	if v == nil {
		return
	}
	return *v, true
}

// OldLamesLegeres returns the old "lames_legeres" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLamesLegeres(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLamesLegeres is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLamesLegeres requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLamesLegeres: %w", err)
	}
	return oldValue.LamesLegeres, nil
}

// AddLamesLegeres adds i to the "lames_legeres" field.
func (m *CharacterMutation) AddLamesLegeres(i int) {
	if m.addlames_legeres != nil {
		*m.addlames_legeres += i
	} else {
		m.addlames_legeres = &i
	}
}

// AddedLamesLegeres returns the value that was added to the "lames_legeres" field in this mutation.
func (m *CharacterMutation) AddedLamesLegeres() (r int, exists bool) {
	v := m.addlames_legeres
	if v == nil {
		return
	}
	return *v, true
}

// ResetLamesLegeres resets all changes to the "lames_legeres" field.
func (m *CharacterMutation) ResetLamesLegeres() {
	m.lames_legeres = nil
	m.addlames_legeres = nil
}

// SetLamesLourdes sets the "lames_lourdes" field.
func (m *CharacterMutation) SetLamesLourdes(i int) {
	m.lames_lourdes = &i
	m.addlames_lourdes = nil
}

// LamesLourdes returns the value of the "lames_lourdes" field in the mutation.
func (m *CharacterMutation) LamesLourdes() (r int, exists bool) {
	v := m.lames_lourdes
	if v == nil {
		return
	}
	return *v, true
}

// OldLamesLourdes returns the old "lames_lourdes" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLamesLourdes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLamesLourdes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLamesLourdes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLamesLourdes: %w", err)
	}
	return oldValue.LamesLourdes, nil
}

// AddLamesLourdes adds i to the "lames_lourdes" field.
func (m *CharacterMutation) AddLamesLourdes(i int) {
	if m.addlames_lourdes != nil {
		*m.addlames_lourdes += i
	} else {
		m.addlames_lourdes = &i
	}
}

// AddedLamesLourdes returns the value that was added to the "lames_lourdes" field in this mutation.
func (m *CharacterMutation) AddedLamesLourdes() (r int, exists bool) {
	v := m.addlames_lourdes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLamesLourdes resets all changes to the "lames_lourdes" field.
func (m *CharacterMutation) ResetLamesLourdes() {
	m.lames_lourdes = nil
	m.addlames_lourdes = nil
}

// SetLances sets the "lances" field.
func (m *CharacterMutation) SetLances(i int) {
	m.lances = &i
	m.addlances = nil
}

// Lances returns the value of the "lances" field in the mutation.
func (m *CharacterMutation) Lances() (r int, exists bool) {
	v := m.lances
	if v == nil {
		return
	}
	return *v, true
}

// OldLances returns the old "lances" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLances(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLances: %w", err)
	}
	return oldValue.Lances, nil
}

// AddLances adds i to the "lances" field.
func (m *CharacterMutation) AddLances(i int) {
	if m.addlances != nil {
		*m.addlances += i
	} else {
		m.addlances = &i
	}
}

// AddedLances returns the value that was added to the "lances" field in this mutation.
func (m *CharacterMutation) AddedLances() (r int, exists bool) {
	v := m.addlances
	if v == nil {
		return
	}
	return *v, true
}

// ResetLances resets all changes to the "lances" field.
func (m *CharacterMutation) ResetLances() {
	m.lances = nil
	m.addlances = nil
}

// SetMarteaux sets the "marteaux" field.
func (m *CharacterMutation) SetMarteaux(i int) {
	m.marteaux = &i
	m.addmarteaux = nil
}

// Marteaux returns the value of the "marteaux" field in the mutation.
func (m *CharacterMutation) Marteaux() (r int, exists bool) {
	v := m.marteaux
	if v == nil {
		return
	}
	return *v, true
}

// OldMarteaux returns the old "marteaux" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldMarteaux(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarteaux is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarteaux requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarteaux: %w", err)
	}
	return oldValue.Marteaux, nil
}

// AddMarteaux adds i to the "marteaux" field.
func (m *CharacterMutation) AddMarteaux(i int) {
	if m.addmarteaux != nil {
		*m.addmarteaux += i
	} else {
		m.addmarteaux = &i
	}
}

// AddedMarteaux returns the value that was added to the "marteaux" field in this mutation.
func (m *CharacterMutation) AddedMarteaux() (r int, exists bool) {
	v := m.addmarteaux
	if v == nil {
		return
	}
	return *v, true
}

// ResetMarteaux resets all changes to the "marteaux" field.
func (m *CharacterMutation) ResetMarteaux() {
	m.marteaux = nil
	m.addmarteaux = nil
}

// SetMainsNues sets the "mains_nues" field.
func (m *CharacterMutation) SetMainsNues(i int) {
	m.mains_nues = &i
	m.addmains_nues = nil
}

// MainsNues returns the value of the "mains_nues" field in the mutation.
func (m *CharacterMutation) MainsNues() (r int, exists bool) {
	v := m.mains_nues
	if v == nil {
		return
	}
	return *v, true
}

// OldMainsNues returns the old "mains_nues" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldMainsNues(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainsNues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainsNues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainsNues: %w", err)
	}
	return oldValue.MainsNues, nil
}

// AddMainsNues adds i to the "mains_nues" field.
func (m *CharacterMutation) AddMainsNues(i int) {
	if m.addmains_nues != nil {
		*m.addmains_nues += i
	} else {
		m.addmains_nues = &i
	}
}

// AddedMainsNues returns the value that was added to the "mains_nues" field in this mutation.
func (m *CharacterMutation) AddedMainsNues() (r int, exists bool) {
	v := m.addmains_nues
	if v == nil {
		return
	}
	return *v, true
}

// ResetMainsNues resets all changes to the "mains_nues" field.
func (m *CharacterMutation) ResetMainsNues() {
	m.mains_nues = nil
	m.addmains_nues = nil
}

// SetMysteres sets the "mysteres" field.
func (m *CharacterMutation) SetMysteres(i int) {
	m.mysteres = &i
	m.addmysteres = nil
}

// Mysteres returns the value of the "mysteres" field in the mutation.
func (m *CharacterMutation) Mysteres() (r int, exists bool) {
	v := m.mysteres
	if v == nil {
		return
	}
	return *v, true
}

// OldMysteres returns the old "mysteres" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldMysteres(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMysteres is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMysteres requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMysteres: %w", err)
	}
	return oldValue.Mysteres, nil
}

// AddMysteres adds i to the "mysteres" field.
func (m *CharacterMutation) AddMysteres(i int) {
	if m.addmysteres != nil {
		*m.addmysteres += i
	} else {
		m.addmysteres = &i
	}
}

// AddedMysteres returns the value that was added to the "mysteres" field in this mutation.
func (m *CharacterMutation) AddedMysteres() (r int, exists bool) {
	v := m.addmysteres
	if v == nil {
		return
	}
	return *v, true
}

// ResetMysteres resets all changes to the "mysteres" field.
func (m *CharacterMutation) ResetMysteres() {
	m.mysteres = nil
	m.addmysteres = nil
}

// SetExplorationSouterraine sets the "exploration_souterraine" field.
func (m *CharacterMutation) SetExplorationSouterraine(i int) {
	m.exploration_souterraine = &i
	m.addexploration_souterraine = nil
}

// ExplorationSouterraine returns the value of the "exploration_souterraine" field in the mutation.
func (m *CharacterMutation) ExplorationSouterraine() (r int, exists bool) {
	v := m.exploration_souterraine
	if v == nil {
		return
	}
	return *v, true
}

// OldExplorationSouterraine returns the old "exploration_souterraine" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldExplorationSouterraine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExplorationSouterraine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExplorationSouterraine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplorationSouterraine: %w", err)
	}
	return oldValue.ExplorationSouterraine, nil
}

// AddExplorationSouterraine adds i to the "exploration_souterraine" field.
func (m *CharacterMutation) AddExplorationSouterraine(i int) {
	if m.addexploration_souterraine != nil {
		*m.addexploration_souterraine += i
	} else {
		m.addexploration_souterraine = &i
	}
}

// AddedExplorationSouterraine returns the value that was added to the "exploration_souterraine" field in this mutation.
func (m *CharacterMutation) AddedExplorationSouterraine() (r int, exists bool) {
	v := m.addexploration_souterraine
	if v == nil {
		return
	}
	return *v, true
}

// ResetExplorationSouterraine resets all changes to the "exploration_souterraine" field.
func (m *CharacterMutation) ResetExplorationSouterraine() {
	m.exploration_souterraine = nil
	m.addexploration_souterraine = nil
}

// SetIngenierie sets the "ingenierie" field.
func (m *CharacterMutation) SetIngenierie(i int) {
	m.ingenierie = &i
	m.addingenierie = nil
}

// Ingenierie returns the value of the "ingenierie" field in the mutation.
func (m *CharacterMutation) Ingenierie() (r int, exists bool) {
	v := m.ingenierie
	if v == nil {
		return
	}
	return *v, true
}

// OldIngenierie returns the old "ingenierie" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldIngenierie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIngenierie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIngenierie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIngenierie: %w", err)
	}
	return oldValue.Ingenierie, nil
}

// AddIngenierie adds i to the "ingenierie" field.
func (m *CharacterMutation) AddIngenierie(i int) {
	if m.addingenierie != nil {
		*m.addingenierie += i
	} else {
		m.addingenierie = &i
	}
}

// AddedIngenierie returns the value that was added to the "ingenierie" field in this mutation.
func (m *CharacterMutation) AddedIngenierie() (r int, exists bool) {
	v := m.addingenierie
	if v == nil {
		return
	}
	return *v, true
}

// ResetIngenierie resets all changes to the "ingenierie" field.
func (m *CharacterMutation) ResetIngenierie() {
	m.ingenierie = nil
	m.addingenierie = nil
}

// SetGeographie sets the "geographie" field.
func (m *CharacterMutation) SetGeographie(i int) {
	m.geographie = &i
	m.addgeographie = nil
}

// Geographie returns the value of the "geographie" field in the mutation.
func (m *CharacterMutation) Geographie() (r int, exists bool) {
	v := m.geographie
	if v == nil {
		return
	}
	return *v, true
}

// OldGeographie returns the old "geographie" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldGeographie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeographie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeographie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeographie: %w", err)
	}
	return oldValue.Geographie, nil
}

// AddGeographie adds i to the "geographie" field.
func (m *CharacterMutation) AddGeographie(i int) {
	if m.addgeographie != nil {
		*m.addgeographie += i
	} else {
		m.addgeographie = &i
	}
}

// AddedGeographie returns the value that was added to the "geographie" field in this mutation.
func (m *CharacterMutation) AddedGeographie() (r int, exists bool) {
	v := m.addgeographie
	if v == nil {
		return
	}
	return *v, true
}

// ResetGeographie resets all changes to the "geographie" field.
func (m *CharacterMutation) ResetGeographie() {
	m.geographie = nil
	m.addgeographie = nil
}

// SetHistoire sets the "histoire" field.
func (m *CharacterMutation) SetHistoire(i int) {
	m.histoire = &i
	m.addhistoire = nil
}

// Histoire returns the value of the "histoire" field in the mutation.
func (m *CharacterMutation) Histoire() (r int, exists bool) {
	v := m.histoire
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoire returns the old "histoire" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldHistoire(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoire: %w", err)
	}
	return oldValue.Histoire, nil
}

// AddHistoire adds i to the "histoire" field.
func (m *CharacterMutation) AddHistoire(i int) {
	if m.addhistoire != nil {
		*m.addhistoire += i
	} else {
		m.addhistoire = &i
	}
}

// AddedHistoire returns the value that was added to the "histoire" field in this mutation.
func (m *CharacterMutation) AddedHistoire() (r int, exists bool) {
	v := m.addhistoire
	if v == nil {
		return
	}
	return *v, true
}

// ResetHistoire resets all changes to the "histoire" field.
func (m *CharacterMutation) ResetHistoire() {
	m.histoire = nil
	m.addhistoire = nil
}

// SetFolklore sets the "folklore" field.
func (m *CharacterMutation) SetFolklore(i int) {
	m.folklore = &i
	m.addfolklore = nil
}

// Folklore returns the value of the "folklore" field in the mutation.
func (m *CharacterMutation) Folklore() (r int, exists bool) {
	v := m.folklore
	if v == nil {
		return
	}
	return *v, true
}

// OldFolklore returns the old "folklore" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldFolklore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolklore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolklore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolklore: %w", err)
	}
	return oldValue.Folklore, nil
}

// AddFolklore adds i to the "folklore" field.
func (m *CharacterMutation) AddFolklore(i int) {
	if m.addfolklore != nil {
		*m.addfolklore += i
	} else {
		m.addfolklore = &i
	}
}

// AddedFolklore returns the value that was added to the "folklore" field in this mutation.
func (m *CharacterMutation) AddedFolklore() (r int, exists bool) {
	v := m.addfolklore
	if v == nil {
		return
	}
	return *v, true
}

// ResetFolklore resets all changes to the "folklore" field.
func (m *CharacterMutation) ResetFolklore() {
	m.folklore = nil
	m.addfolklore = nil
}

// SetNature sets the "nature" field.
func (m *CharacterMutation) SetNature(i int) {
	m.nature = &i
	m.addnature = nil
}

// Nature returns the value of the "nature" field in the mutation.
func (m *CharacterMutation) Nature() (r int, exists bool) {
	v := m.nature
	if v == nil {
		return
	}
	return *v, true
}

// OldNature returns the old "nature" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldNature(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNature: %w", err)
	}
	return oldValue.Nature, nil
}

// AddNature adds i to the "nature" field.
func (m *CharacterMutation) AddNature(i int) {
	if m.addnature != nil {
		*m.addnature += i
	} else {
		m.addnature = &i
	}
}

// AddedNature returns the value that was added to the "nature" field in this mutation.
func (m *CharacterMutation) AddedNature() (r int, exists bool) {
	v := m.addnature
	if v == nil {
		return
	}
	return *v, true
}

// ResetNature resets all changes to the "nature" field.
func (m *CharacterMutation) ResetNature() {
	m.nature = nil
	m.addnature = nil
}

// SetNoblesse sets the "noblesse" field.
func (m *CharacterMutation) SetNoblesse(i int) {
	m.noblesse = &i
	m.addnoblesse = nil
}

// Noblesse returns the value of the "noblesse" field in the mutation.
func (m *CharacterMutation) Noblesse() (r int, exists bool) {
	v := m.noblesse
	if v == nil {
		return
	}
	return *v, true
}

// OldNoblesse returns the old "noblesse" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldNoblesse(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoblesse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoblesse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoblesse: %w", err)
	}
	return oldValue.Noblesse, nil
}

// AddNoblesse adds i to the "noblesse" field.
func (m *CharacterMutation) AddNoblesse(i int) {
	if m.addnoblesse != nil {
		*m.addnoblesse += i
	} else {
		m.addnoblesse = &i
	}
}

// AddedNoblesse returns the value that was added to the "noblesse" field in this mutation.
func (m *CharacterMutation) AddedNoblesse() (r int, exists bool) {
	v := m.addnoblesse
	if v == nil {
		return
	}
	return *v, true
}

// ResetNoblesse resets all changes to the "noblesse" field.
func (m *CharacterMutation) ResetNoblesse() {
	m.noblesse = nil
	m.addnoblesse = nil
}

// SetPlans sets the "plans" field.
func (m *CharacterMutation) SetPlans(i int) {
	m.plans = &i
	m.addplans = nil
}

// Plans returns the value of the "plans" field in the mutation.
func (m *CharacterMutation) Plans() (r int, exists bool) {
	v := m.plans
	if v == nil {
		return
	}
	return *v, true
}

// OldPlans returns the old "plans" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldPlans(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlans is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlans requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlans: %w", err)
	}
	return oldValue.Plans, nil
}

// AddPlans adds i to the "plans" field.
func (m *CharacterMutation) AddPlans(i int) {
	if m.addplans != nil {
		*m.addplans += i
	} else {
		m.addplans = &i
	}
}

// AddedPlans returns the value that was added to the "plans" field in this mutation.
func (m *CharacterMutation) AddedPlans() (r int, exists bool) {
	v := m.addplans
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlans resets all changes to the "plans" field.
func (m *CharacterMutation) ResetPlans() {
	m.plans = nil
	m.addplans = nil
}

// SetReligon sets the "religon" field.
func (m *CharacterMutation) SetReligon(i int) {
	m.religon = &i
	m.addreligon = nil
}

// Religon returns the value of the "religon" field in the mutation.
func (m *CharacterMutation) Religon() (r int, exists bool) {
	v := m.religon
	if v == nil {
		return
	}
	return *v, true
}

// OldReligon returns the old "religon" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldReligon(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReligon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReligon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReligon: %w", err)
	}
	return oldValue.Religon, nil
}

// AddReligon adds i to the "religon" field.
func (m *CharacterMutation) AddReligon(i int) {
	if m.addreligon != nil {
		*m.addreligon += i
	} else {
		m.addreligon = &i
	}
}

// AddedReligon returns the value that was added to the "religon" field in this mutation.
func (m *CharacterMutation) AddedReligon() (r int, exists bool) {
	v := m.addreligon
	if v == nil {
		return
	}
	return *v, true
}

// ResetReligon resets all changes to the "religon" field.
func (m *CharacterMutation) ResetReligon() {
	m.religon = nil
	m.addreligon = nil
}

// SetAnatomie sets the "anatomie" field.
func (m *CharacterMutation) SetAnatomie(i int) {
	m.anatomie = &i
	m.addanatomie = nil
}

// Anatomie returns the value of the "anatomie" field in the mutation.
func (m *CharacterMutation) Anatomie() (r int, exists bool) {
	v := m.anatomie
	if v == nil {
		return
	}
	return *v, true
}

// OldAnatomie returns the old "anatomie" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldAnatomie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnatomie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnatomie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnatomie: %w", err)
	}
	return oldValue.Anatomie, nil
}

// AddAnatomie adds i to the "anatomie" field.
func (m *CharacterMutation) AddAnatomie(i int) {
	if m.addanatomie != nil {
		*m.addanatomie += i
	} else {
		m.addanatomie = &i
	}
}

// AddedAnatomie returns the value that was added to the "anatomie" field in this mutation.
func (m *CharacterMutation) AddedAnatomie() (r int, exists bool) {
	v := m.addanatomie
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnatomie resets all changes to the "anatomie" field.
func (m *CharacterMutation) ResetAnatomie() {
	m.anatomie = nil
	m.addanatomie = nil
}

// SetMagieTheorique sets the "magie_theorique" field.
func (m *CharacterMutation) SetMagieTheorique(i int) {
	m.magie_theorique = &i
	m.addmagie_theorique = nil
}

// MagieTheorique returns the value of the "magie_theorique" field in the mutation.
func (m *CharacterMutation) MagieTheorique() (r int, exists bool) {
	v := m.magie_theorique
	if v == nil {
		return
	}
	return *v, true
}

// OldMagieTheorique returns the old "magie_theorique" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldMagieTheorique(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagieTheorique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagieTheorique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagieTheorique: %w", err)
	}
	return oldValue.MagieTheorique, nil
}

// AddMagieTheorique adds i to the "magie_theorique" field.
func (m *CharacterMutation) AddMagieTheorique(i int) {
	if m.addmagie_theorique != nil {
		*m.addmagie_theorique += i
	} else {
		m.addmagie_theorique = &i
	}
}

// AddedMagieTheorique returns the value that was added to the "magie_theorique" field in this mutation.
func (m *CharacterMutation) AddedMagieTheorique() (r int, exists bool) {
	v := m.addmagie_theorique
	if v == nil {
		return
	}
	return *v, true
}

// ResetMagieTheorique resets all changes to the "magie_theorique" field.
func (m *CharacterMutation) ResetMagieTheorique() {
	m.magie_theorique = nil
	m.addmagie_theorique = nil
}

// SetEconomie sets the "economie" field.
func (m *CharacterMutation) SetEconomie(i int) {
	m.economie = &i
	m.addeconomie = nil
}

// Economie returns the value of the "economie" field in the mutation.
func (m *CharacterMutation) Economie() (r int, exists bool) {
	v := m.economie
	if v == nil {
		return
	}
	return *v, true
}

// OldEconomie returns the old "economie" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldEconomie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEconomie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEconomie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEconomie: %w", err)
	}
	return oldValue.Economie, nil
}

// AddEconomie adds i to the "economie" field.
func (m *CharacterMutation) AddEconomie(i int) {
	if m.addeconomie != nil {
		*m.addeconomie += i
	} else {
		m.addeconomie = &i
	}
}

// AddedEconomie returns the value that was added to the "economie" field in this mutation.
func (m *CharacterMutation) AddedEconomie() (r int, exists bool) {
	v := m.addeconomie
	if v == nil {
		return
	}
	return *v, true
}

// ResetEconomie resets all changes to the "economie" field.
func (m *CharacterMutation) ResetEconomie() {
	m.economie = nil
	m.addeconomie = nil
}

// SetLinguistique sets the "linguistique" field.
func (m *CharacterMutation) SetLinguistique(i int) {
	m.linguistique = &i
	m.addlinguistique = nil
}

// Linguistique returns the value of the "linguistique" field in the mutation.
func (m *CharacterMutation) Linguistique() (r int, exists bool) {
	v := m.linguistique
	if v == nil {
		return
	}
	return *v, true
}

// OldLinguistique returns the old "linguistique" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLinguistique(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinguistique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinguistique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinguistique: %w", err)
	}
	return oldValue.Linguistique, nil
}

// AddLinguistique adds i to the "linguistique" field.
func (m *CharacterMutation) AddLinguistique(i int) {
	if m.addlinguistique != nil {
		*m.addlinguistique += i
	} else {
		m.addlinguistique = &i
	}
}

// AddedLinguistique returns the value that was added to the "linguistique" field in this mutation.
func (m *CharacterMutation) AddedLinguistique() (r int, exists bool) {
	v := m.addlinguistique
	if v == nil {
		return
	}
	return *v, true
}

// ResetLinguistique resets all changes to the "linguistique" field.
func (m *CharacterMutation) ResetLinguistique() {
	m.linguistique = nil
	m.addlinguistique = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Character, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 43)
	if m.name != nil {
		fields = append(fields, character.FieldName)
	}
	if m.combat != nil {
		fields = append(fields, character.FieldCombat)
	}
	if m.connaissance != nil {
		fields = append(fields, character.FieldConnaissance)
	}
	if m.discretion != nil {
		fields = append(fields, character.FieldDiscretion)
	}
	if m.endurance != nil {
		fields = append(fields, character.FieldEndurance)
	}
	if m.force != nil {
		fields = append(fields, character.FieldForce)
	}
	if m.habilite != nil {
		fields = append(fields, character.FieldHabilite)
	}
	if m.mouvement != nil {
		fields = append(fields, character.FieldMouvement)
	}
	if m.perception != nil {
		fields = append(fields, character.FieldPerception)
	}
	if m.sociabilite != nil {
		fields = append(fields, character.FieldSociabilite)
	}
	if m.survie != nil {
		fields = append(fields, character.FieldSurvie)
	}
	if m.tir != nil {
		fields = append(fields, character.FieldTir)
	}
	if m.volonte != nil {
		fields = append(fields, character.FieldVolonte)
	}
	if m.exp != nil {
		fields = append(fields, character.FieldExp)
	}
	if m.armes_hast != nil {
		fields = append(fields, character.FieldArmesHast)
	}
	if m.armes_moine != nil {
		fields = append(fields, character.FieldArmesMoine)
	}
	if m.armes_doubles != nil {
		fields = append(fields, character.FieldArmesDoubles)
	}
	if m.armes_naturelles != nil {
		fields = append(fields, character.FieldArmesNaturelles)
	}
	if m.batons != nil {
		fields = append(fields, character.FieldBatons)
	}
	if m.cimeterres != nil {
		fields = append(fields, character.FieldCimeterres)
	}
	if m.fleaux != nil {
		fields = append(fields, character.FieldFleaux)
	}
	if m.fouets != nil {
		fields = append(fields, character.FieldFouets)
	}
	if m.haches != nil {
		fields = append(fields, character.FieldHaches)
	}
	if m.katanas != nil {
		fields = append(fields, character.FieldKatanas)
	}
	if m.lames_legeres != nil {
		fields = append(fields, character.FieldLamesLegeres)
	}
	if m.lames_lourdes != nil {
		fields = append(fields, character.FieldLamesLourdes)
	}
	if m.lances != nil {
		fields = append(fields, character.FieldLances)
	}
	if m.marteaux != nil {
		fields = append(fields, character.FieldMarteaux)
	}
	if m.mains_nues != nil {
		fields = append(fields, character.FieldMainsNues)
	}
	if m.mysteres != nil {
		fields = append(fields, character.FieldMysteres)
	}
	if m.exploration_souterraine != nil {
		fields = append(fields, character.FieldExplorationSouterraine)
	}
	if m.ingenierie != nil {
		fields = append(fields, character.FieldIngenierie)
	}
	if m.geographie != nil {
		fields = append(fields, character.FieldGeographie)
	}
	if m.histoire != nil {
		fields = append(fields, character.FieldHistoire)
	}
	if m.folklore != nil {
		fields = append(fields, character.FieldFolklore)
	}
	if m.nature != nil {
		fields = append(fields, character.FieldNature)
	}
	if m.noblesse != nil {
		fields = append(fields, character.FieldNoblesse)
	}
	if m.plans != nil {
		fields = append(fields, character.FieldPlans)
	}
	if m.religon != nil {
		fields = append(fields, character.FieldReligon)
	}
	if m.anatomie != nil {
		fields = append(fields, character.FieldAnatomie)
	}
	if m.magie_theorique != nil {
		fields = append(fields, character.FieldMagieTheorique)
	}
	if m.economie != nil {
		fields = append(fields, character.FieldEconomie)
	}
	if m.linguistique != nil {
		fields = append(fields, character.FieldLinguistique)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldName:
		return m.Name()
	case character.FieldCombat:
		return m.Combat()
	case character.FieldConnaissance:
		return m.Connaissance()
	case character.FieldDiscretion:
		return m.Discretion()
	case character.FieldEndurance:
		return m.Endurance()
	case character.FieldForce:
		return m.Force()
	case character.FieldHabilite:
		return m.Habilite()
	case character.FieldMouvement:
		return m.Mouvement()
	case character.FieldPerception:
		return m.Perception()
	case character.FieldSociabilite:
		return m.Sociabilite()
	case character.FieldSurvie:
		return m.Survie()
	case character.FieldTir:
		return m.Tir()
	case character.FieldVolonte:
		return m.Volonte()
	case character.FieldExp:
		return m.Exp()
	case character.FieldArmesHast:
		return m.ArmesHast()
	case character.FieldArmesMoine:
		return m.ArmesMoine()
	case character.FieldArmesDoubles:
		return m.ArmesDoubles()
	case character.FieldArmesNaturelles:
		return m.ArmesNaturelles()
	case character.FieldBatons:
		return m.Batons()
	case character.FieldCimeterres:
		return m.Cimeterres()
	case character.FieldFleaux:
		return m.Fleaux()
	case character.FieldFouets:
		return m.Fouets()
	case character.FieldHaches:
		return m.Haches()
	case character.FieldKatanas:
		return m.Katanas()
	case character.FieldLamesLegeres:
		return m.LamesLegeres()
	case character.FieldLamesLourdes:
		return m.LamesLourdes()
	case character.FieldLances:
		return m.Lances()
	case character.FieldMarteaux:
		return m.Marteaux()
	case character.FieldMainsNues:
		return m.MainsNues()
	case character.FieldMysteres:
		return m.Mysteres()
	case character.FieldExplorationSouterraine:
		return m.ExplorationSouterraine()
	case character.FieldIngenierie:
		return m.Ingenierie()
	case character.FieldGeographie:
		return m.Geographie()
	case character.FieldHistoire:
		return m.Histoire()
	case character.FieldFolklore:
		return m.Folklore()
	case character.FieldNature:
		return m.Nature()
	case character.FieldNoblesse:
		return m.Noblesse()
	case character.FieldPlans:
		return m.Plans()
	case character.FieldReligon:
		return m.Religon()
	case character.FieldAnatomie:
		return m.Anatomie()
	case character.FieldMagieTheorique:
		return m.MagieTheorique()
	case character.FieldEconomie:
		return m.Economie()
	case character.FieldLinguistique:
		return m.Linguistique()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldName:
		return m.OldName(ctx)
	case character.FieldCombat:
		return m.OldCombat(ctx)
	case character.FieldConnaissance:
		return m.OldConnaissance(ctx)
	case character.FieldDiscretion:
		return m.OldDiscretion(ctx)
	case character.FieldEndurance:
		return m.OldEndurance(ctx)
	case character.FieldForce:
		return m.OldForce(ctx)
	case character.FieldHabilite:
		return m.OldHabilite(ctx)
	case character.FieldMouvement:
		return m.OldMouvement(ctx)
	case character.FieldPerception:
		return m.OldPerception(ctx)
	case character.FieldSociabilite:
		return m.OldSociabilite(ctx)
	case character.FieldSurvie:
		return m.OldSurvie(ctx)
	case character.FieldTir:
		return m.OldTir(ctx)
	case character.FieldVolonte:
		return m.OldVolonte(ctx)
	case character.FieldExp:
		return m.OldExp(ctx)
	case character.FieldArmesHast:
		return m.OldArmesHast(ctx)
	case character.FieldArmesMoine:
		return m.OldArmesMoine(ctx)
	case character.FieldArmesDoubles:
		return m.OldArmesDoubles(ctx)
	case character.FieldArmesNaturelles:
		return m.OldArmesNaturelles(ctx)
	case character.FieldBatons:
		return m.OldBatons(ctx)
	case character.FieldCimeterres:
		return m.OldCimeterres(ctx)
	case character.FieldFleaux:
		return m.OldFleaux(ctx)
	case character.FieldFouets:
		return m.OldFouets(ctx)
	case character.FieldHaches:
		return m.OldHaches(ctx)
	case character.FieldKatanas:
		return m.OldKatanas(ctx)
	case character.FieldLamesLegeres:
		return m.OldLamesLegeres(ctx)
	case character.FieldLamesLourdes:
		return m.OldLamesLourdes(ctx)
	case character.FieldLances:
		return m.OldLances(ctx)
	case character.FieldMarteaux:
		return m.OldMarteaux(ctx)
	case character.FieldMainsNues:
		return m.OldMainsNues(ctx)
	case character.FieldMysteres:
		return m.OldMysteres(ctx)
	case character.FieldExplorationSouterraine:
		return m.OldExplorationSouterraine(ctx)
	case character.FieldIngenierie:
		return m.OldIngenierie(ctx)
	case character.FieldGeographie:
		return m.OldGeographie(ctx)
	case character.FieldHistoire:
		return m.OldHistoire(ctx)
	case character.FieldFolklore:
		return m.OldFolklore(ctx)
	case character.FieldNature:
		return m.OldNature(ctx)
	case character.FieldNoblesse:
		return m.OldNoblesse(ctx)
	case character.FieldPlans:
		return m.OldPlans(ctx)
	case character.FieldReligon:
		return m.OldReligon(ctx)
	case character.FieldAnatomie:
		return m.OldAnatomie(ctx)
	case character.FieldMagieTheorique:
		return m.OldMagieTheorique(ctx)
	case character.FieldEconomie:
		return m.OldEconomie(ctx)
	case character.FieldLinguistique:
		return m.OldLinguistique(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case character.FieldCombat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombat(v)
		return nil
	case character.FieldConnaissance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnaissance(v)
		return nil
	case character.FieldDiscretion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscretion(v)
		return nil
	case character.FieldEndurance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndurance(v)
		return nil
	case character.FieldForce:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForce(v)
		return nil
	case character.FieldHabilite:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHabilite(v)
		return nil
	case character.FieldMouvement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMouvement(v)
		return nil
	case character.FieldPerception:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerception(v)
		return nil
	case character.FieldSociabilite:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSociabilite(v)
		return nil
	case character.FieldSurvie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurvie(v)
		return nil
	case character.FieldTir:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTir(v)
		return nil
	case character.FieldVolonte:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolonte(v)
		return nil
	case character.FieldExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExp(v)
		return nil
	case character.FieldArmesHast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArmesHast(v)
		return nil
	case character.FieldArmesMoine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArmesMoine(v)
		return nil
	case character.FieldArmesDoubles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArmesDoubles(v)
		return nil
	case character.FieldArmesNaturelles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArmesNaturelles(v)
		return nil
	case character.FieldBatons:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatons(v)
		return nil
	case character.FieldCimeterres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCimeterres(v)
		return nil
	case character.FieldFleaux:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleaux(v)
		return nil
	case character.FieldFouets:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFouets(v)
		return nil
	case character.FieldHaches:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHaches(v)
		return nil
	case character.FieldKatanas:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKatanas(v)
		return nil
	case character.FieldLamesLegeres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLamesLegeres(v)
		return nil
	case character.FieldLamesLourdes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLamesLourdes(v)
		return nil
	case character.FieldLances:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLances(v)
		return nil
	case character.FieldMarteaux:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarteaux(v)
		return nil
	case character.FieldMainsNues:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainsNues(v)
		return nil
	case character.FieldMysteres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMysteres(v)
		return nil
	case character.FieldExplorationSouterraine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplorationSouterraine(v)
		return nil
	case character.FieldIngenierie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIngenierie(v)
		return nil
	case character.FieldGeographie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeographie(v)
		return nil
	case character.FieldHistoire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoire(v)
		return nil
	case character.FieldFolklore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolklore(v)
		return nil
	case character.FieldNature:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNature(v)
		return nil
	case character.FieldNoblesse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoblesse(v)
		return nil
	case character.FieldPlans:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlans(v)
		return nil
	case character.FieldReligon:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReligon(v)
		return nil
	case character.FieldAnatomie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnatomie(v)
		return nil
	case character.FieldMagieTheorique:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagieTheorique(v)
		return nil
	case character.FieldEconomie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEconomie(v)
		return nil
	case character.FieldLinguistique:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinguistique(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	var fields []string
	if m.addcombat != nil {
		fields = append(fields, character.FieldCombat)
	}
	if m.addconnaissance != nil {
		fields = append(fields, character.FieldConnaissance)
	}
	if m.adddiscretion != nil {
		fields = append(fields, character.FieldDiscretion)
	}
	if m.addendurance != nil {
		fields = append(fields, character.FieldEndurance)
	}
	if m.addforce != nil {
		fields = append(fields, character.FieldForce)
	}
	if m.addhabilite != nil {
		fields = append(fields, character.FieldHabilite)
	}
	if m.addmouvement != nil {
		fields = append(fields, character.FieldMouvement)
	}
	if m.addperception != nil {
		fields = append(fields, character.FieldPerception)
	}
	if m.addsociabilite != nil {
		fields = append(fields, character.FieldSociabilite)
	}
	if m.addsurvie != nil {
		fields = append(fields, character.FieldSurvie)
	}
	if m.addtir != nil {
		fields = append(fields, character.FieldTir)
	}
	if m.addvolonte != nil {
		fields = append(fields, character.FieldVolonte)
	}
	if m.addexp != nil {
		fields = append(fields, character.FieldExp)
	}
	if m.addarmes_hast != nil {
		fields = append(fields, character.FieldArmesHast)
	}
	if m.addarmes_moine != nil {
		fields = append(fields, character.FieldArmesMoine)
	}
	if m.addarmes_doubles != nil {
		fields = append(fields, character.FieldArmesDoubles)
	}
	if m.addarmes_naturelles != nil {
		fields = append(fields, character.FieldArmesNaturelles)
	}
	if m.addbatons != nil {
		fields = append(fields, character.FieldBatons)
	}
	if m.addcimeterres != nil {
		fields = append(fields, character.FieldCimeterres)
	}
	if m.addfleaux != nil {
		fields = append(fields, character.FieldFleaux)
	}
	if m.addfouets != nil {
		fields = append(fields, character.FieldFouets)
	}
	if m.addhaches != nil {
		fields = append(fields, character.FieldHaches)
	}
	if m.addkatanas != nil {
		fields = append(fields, character.FieldKatanas)
	}
	if m.addlames_legeres != nil {
		fields = append(fields, character.FieldLamesLegeres)
	}
	if m.addlames_lourdes != nil {
		fields = append(fields, character.FieldLamesLourdes)
	}
	if m.addlances != nil {
		fields = append(fields, character.FieldLances)
	}
	if m.addmarteaux != nil {
		fields = append(fields, character.FieldMarteaux)
	}
	if m.addmains_nues != nil {
		fields = append(fields, character.FieldMainsNues)
	}
	if m.addmysteres != nil {
		fields = append(fields, character.FieldMysteres)
	}
	if m.addexploration_souterraine != nil {
		fields = append(fields, character.FieldExplorationSouterraine)
	}
	if m.addingenierie != nil {
		fields = append(fields, character.FieldIngenierie)
	}
	if m.addgeographie != nil {
		fields = append(fields, character.FieldGeographie)
	}
	if m.addhistoire != nil {
		fields = append(fields, character.FieldHistoire)
	}
	if m.addfolklore != nil {
		fields = append(fields, character.FieldFolklore)
	}
	if m.addnature != nil {
		fields = append(fields, character.FieldNature)
	}
	if m.addnoblesse != nil {
		fields = append(fields, character.FieldNoblesse)
	}
	if m.addplans != nil {
		fields = append(fields, character.FieldPlans)
	}
	if m.addreligon != nil {
		fields = append(fields, character.FieldReligon)
	}
	if m.addanatomie != nil {
		fields = append(fields, character.FieldAnatomie)
	}
	if m.addmagie_theorique != nil {
		fields = append(fields, character.FieldMagieTheorique)
	}
	if m.addeconomie != nil {
		fields = append(fields, character.FieldEconomie)
	}
	if m.addlinguistique != nil {
		fields = append(fields, character.FieldLinguistique)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case character.FieldCombat:
		return m.AddedCombat()
	case character.FieldConnaissance:
		return m.AddedConnaissance()
	case character.FieldDiscretion:
		return m.AddedDiscretion()
	case character.FieldEndurance:
		return m.AddedEndurance()
	case character.FieldForce:
		return m.AddedForce()
	case character.FieldHabilite:
		return m.AddedHabilite()
	case character.FieldMouvement:
		return m.AddedMouvement()
	case character.FieldPerception:
		return m.AddedPerception()
	case character.FieldSociabilite:
		return m.AddedSociabilite()
	case character.FieldSurvie:
		return m.AddedSurvie()
	case character.FieldTir:
		return m.AddedTir()
	case character.FieldVolonte:
		return m.AddedVolonte()
	case character.FieldExp:
		return m.AddedExp()
	case character.FieldArmesHast:
		return m.AddedArmesHast()
	case character.FieldArmesMoine:
		return m.AddedArmesMoine()
	case character.FieldArmesDoubles:
		return m.AddedArmesDoubles()
	case character.FieldArmesNaturelles:
		return m.AddedArmesNaturelles()
	case character.FieldBatons:
		return m.AddedBatons()
	case character.FieldCimeterres:
		return m.AddedCimeterres()
	case character.FieldFleaux:
		return m.AddedFleaux()
	case character.FieldFouets:
		return m.AddedFouets()
	case character.FieldHaches:
		return m.AddedHaches()
	case character.FieldKatanas:
		return m.AddedKatanas()
	case character.FieldLamesLegeres:
		return m.AddedLamesLegeres()
	case character.FieldLamesLourdes:
		return m.AddedLamesLourdes()
	case character.FieldLances:
		return m.AddedLances()
	case character.FieldMarteaux:
		return m.AddedMarteaux()
	case character.FieldMainsNues:
		return m.AddedMainsNues()
	case character.FieldMysteres:
		return m.AddedMysteres()
	case character.FieldExplorationSouterraine:
		return m.AddedExplorationSouterraine()
	case character.FieldIngenierie:
		return m.AddedIngenierie()
	case character.FieldGeographie:
		return m.AddedGeographie()
	case character.FieldHistoire:
		return m.AddedHistoire()
	case character.FieldFolklore:
		return m.AddedFolklore()
	case character.FieldNature:
		return m.AddedNature()
	case character.FieldNoblesse:
		return m.AddedNoblesse()
	case character.FieldPlans:
		return m.AddedPlans()
	case character.FieldReligon:
		return m.AddedReligon()
	case character.FieldAnatomie:
		return m.AddedAnatomie()
	case character.FieldMagieTheorique:
		return m.AddedMagieTheorique()
	case character.FieldEconomie:
		return m.AddedEconomie()
	case character.FieldLinguistique:
		return m.AddedLinguistique()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case character.FieldCombat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombat(v)
		return nil
	case character.FieldConnaissance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnaissance(v)
		return nil
	case character.FieldDiscretion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscretion(v)
		return nil
	case character.FieldEndurance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndurance(v)
		return nil
	case character.FieldForce:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForce(v)
		return nil
	case character.FieldHabilite:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHabilite(v)
		return nil
	case character.FieldMouvement:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMouvement(v)
		return nil
	case character.FieldPerception:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerception(v)
		return nil
	case character.FieldSociabilite:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSociabilite(v)
		return nil
	case character.FieldSurvie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurvie(v)
		return nil
	case character.FieldTir:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTir(v)
		return nil
	case character.FieldVolonte:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolonte(v)
		return nil
	case character.FieldExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExp(v)
		return nil
	case character.FieldArmesHast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArmesHast(v)
		return nil
	case character.FieldArmesMoine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArmesMoine(v)
		return nil
	case character.FieldArmesDoubles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArmesDoubles(v)
		return nil
	case character.FieldArmesNaturelles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArmesNaturelles(v)
		return nil
	case character.FieldBatons:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatons(v)
		return nil
	case character.FieldCimeterres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCimeterres(v)
		return nil
	case character.FieldFleaux:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFleaux(v)
		return nil
	case character.FieldFouets:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFouets(v)
		return nil
	case character.FieldHaches:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHaches(v)
		return nil
	case character.FieldKatanas:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKatanas(v)
		return nil
	case character.FieldLamesLegeres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLamesLegeres(v)
		return nil
	case character.FieldLamesLourdes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLamesLourdes(v)
		return nil
	case character.FieldLances:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLances(v)
		return nil
	case character.FieldMarteaux:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarteaux(v)
		return nil
	case character.FieldMainsNues:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMainsNues(v)
		return nil
	case character.FieldMysteres:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMysteres(v)
		return nil
	case character.FieldExplorationSouterraine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExplorationSouterraine(v)
		return nil
	case character.FieldIngenierie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIngenierie(v)
		return nil
	case character.FieldGeographie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGeographie(v)
		return nil
	case character.FieldHistoire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHistoire(v)
		return nil
	case character.FieldFolklore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFolklore(v)
		return nil
	case character.FieldNature:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNature(v)
		return nil
	case character.FieldNoblesse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoblesse(v)
		return nil
	case character.FieldPlans:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlans(v)
		return nil
	case character.FieldReligon:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReligon(v)
		return nil
	case character.FieldAnatomie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnatomie(v)
		return nil
	case character.FieldMagieTheorique:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagieTheorique(v)
		return nil
	case character.FieldEconomie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEconomie(v)
		return nil
	case character.FieldLinguistique:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLinguistique(v)
		return nil
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldName:
		m.ResetName()
		return nil
	case character.FieldCombat:
		m.ResetCombat()
		return nil
	case character.FieldConnaissance:
		m.ResetConnaissance()
		return nil
	case character.FieldDiscretion:
		m.ResetDiscretion()
		return nil
	case character.FieldEndurance:
		m.ResetEndurance()
		return nil
	case character.FieldForce:
		m.ResetForce()
		return nil
	case character.FieldHabilite:
		m.ResetHabilite()
		return nil
	case character.FieldMouvement:
		m.ResetMouvement()
		return nil
	case character.FieldPerception:
		m.ResetPerception()
		return nil
	case character.FieldSociabilite:
		m.ResetSociabilite()
		return nil
	case character.FieldSurvie:
		m.ResetSurvie()
		return nil
	case character.FieldTir:
		m.ResetTir()
		return nil
	case character.FieldVolonte:
		m.ResetVolonte()
		return nil
	case character.FieldExp:
		m.ResetExp()
		return nil
	case character.FieldArmesHast:
		m.ResetArmesHast()
		return nil
	case character.FieldArmesMoine:
		m.ResetArmesMoine()
		return nil
	case character.FieldArmesDoubles:
		m.ResetArmesDoubles()
		return nil
	case character.FieldArmesNaturelles:
		m.ResetArmesNaturelles()
		return nil
	case character.FieldBatons:
		m.ResetBatons()
		return nil
	case character.FieldCimeterres:
		m.ResetCimeterres()
		return nil
	case character.FieldFleaux:
		m.ResetFleaux()
		return nil
	case character.FieldFouets:
		m.ResetFouets()
		return nil
	case character.FieldHaches:
		m.ResetHaches()
		return nil
	case character.FieldKatanas:
		m.ResetKatanas()
		return nil
	case character.FieldLamesLegeres:
		m.ResetLamesLegeres()
		return nil
	case character.FieldLamesLourdes:
		m.ResetLamesLourdes()
		return nil
	case character.FieldLances:
		m.ResetLances()
		return nil
	case character.FieldMarteaux:
		m.ResetMarteaux()
		return nil
	case character.FieldMainsNues:
		m.ResetMainsNues()
		return nil
	case character.FieldMysteres:
		m.ResetMysteres()
		return nil
	case character.FieldExplorationSouterraine:
		m.ResetExplorationSouterraine()
		return nil
	case character.FieldIngenierie:
		m.ResetIngenierie()
		return nil
	case character.FieldGeographie:
		m.ResetGeographie()
		return nil
	case character.FieldHistoire:
		m.ResetHistoire()
		return nil
	case character.FieldFolklore:
		m.ResetFolklore()
		return nil
	case character.FieldNature:
		m.ResetNature()
		return nil
	case character.FieldNoblesse:
		m.ResetNoblesse()
		return nil
	case character.FieldPlans:
		m.ResetPlans()
		return nil
	case character.FieldReligon:
		m.ResetReligon()
		return nil
	case character.FieldAnatomie:
		m.ResetAnatomie()
		return nil
	case character.FieldMagieTheorique:
		m.ResetMagieTheorique()
		return nil
	case character.FieldEconomie:
		m.ResetEconomie()
		return nil
	case character.FieldLinguistique:
		m.ResetLinguistique()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Character edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
